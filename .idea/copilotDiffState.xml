<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="/InheritanceResolverTest (snapshot).java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="/InheritanceResolverTest (snapshot).java" />
              <option name="originalContent" value="package logic.rule.evaluator;&#10;&#10;public class InheritanceResolverTest {&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package logic.rule.evaluator;&#13;&#10;&#13;&#10;import model.entity.Entity;&#13;&#10;import model.entity.TypeRegistry;&#13;&#10;import model.map.LevelMap;&#13;&#10;import model.rule.Rule;&#13;&#10;import model.rule.Ruleset;&#13;&#10;import org.junit.jupiter.api.BeforeEach;&#13;&#10;import org.junit.jupiter.api.Test;&#13;&#10;&#13;&#10;import java.util.List;&#13;&#10;&#13;&#10;import static org.junit.jupiter.api.Assertions.*;&#13;&#10;&#13;&#10;class InheritanceResolverTest {&#13;&#10;&#13;&#10;    private InheritanceResolver resolver;&#13;&#10;    private LevelMap levelMap;&#13;&#10;    private Ruleset ruleset;&#13;&#10;    private Entity javaEntity;&#13;&#10;    private Entity errorEntity;&#13;&#10;&#13;&#10;    @BeforeEach&#13;&#10;    void setUp() {&#13;&#10;        resolver = new InheritanceResolver();&#13;&#10;        levelMap = new LevelMap(10, 10);&#13;&#10;        ruleset = new Ruleset();&#13;&#10;        javaEntity = new Entity(TypeRegistry.JAVA);&#13;&#10;        errorEntity = new Entity(TypeRegistry.ERROR);&#13;&#10;        levelMap.setPosition(javaEntity, 5, 5);&#13;&#10;        levelMap.setPosition(errorEntity, 6, 6);&#13;&#10;    }&#13;&#10;&#13;&#10;    /** Helper: creates &quot;subjectText EXTEND objectText&quot; rule */&#13;&#10;    private Rule extendRule(Entity subjectText, Entity objectText) {&#13;&#10;        return new Rule(subjectText, new Entity(TypeRegistry.EXTEND), objectText, List.of());&#13;&#10;    }&#13;&#10;&#13;&#10;    // ── Direct match ──────────────────────────────────────────────────────────&#13;&#10;&#13;&#10;    @Test&#13;&#10;    void testDirectTypeMatch_ReturnsTrue() {&#13;&#10;        // JAVA instanceof JAVA → true (same type, no rules needed)&#13;&#10;        assertTrue(resolver.isInstanceOf(javaEntity, TypeRegistry.JAVA, levelMap, ruleset));&#13;&#10;    }&#13;&#10;&#13;&#10;    // ── No EXTEND rules ───────────────────────────────────────────────────────&#13;&#10;&#13;&#10;    @Test&#13;&#10;    void testDifferentType_NoExtendRules_ReturnsFalse() {&#13;&#10;        // No EXTEND rules → JAVA cannot be instanceof DOCUMENT&#13;&#10;        assertFalse(resolver.isInstanceOf(javaEntity, TypeRegistry.DOCUMENT, levelMap, ruleset));&#13;&#10;    }&#13;&#10;&#13;&#10;    // ── Single-level inheritance ──────────────────────────────────────────────&#13;&#10;&#13;&#10;    @Test&#13;&#10;    void testSingleLevel_MatchingTarget_ReturnsTrue() {&#13;&#10;        // JAVA EXTEND DOCUMENT → java entity instanceof DOCUMENT&#13;&#10;        ruleset.setRules(List.of(&#13;&#10;                extendRule(new Entity(TypeRegistry.TEXT_JAVA), new Entity(TypeRegistry.TEXT_DOCUMENT))&#13;&#10;        ));&#13;&#10;        assertTrue(resolver.isInstanceOf(javaEntity, TypeRegistry.DOCUMENT, levelMap, ruleset));&#13;&#10;    }&#13;&#10;&#13;&#10;    @Test&#13;&#10;    void testSingleLevel_UnrelatedTarget_ReturnsFalse() {&#13;&#10;        // JAVA EXTEND DOCUMENT → java entity instanceof FLAG should still be false&#13;&#10;        ruleset.setRules(List.of(&#13;&#10;                extendRule(new Entity(TypeRegistry.TEXT_JAVA), new Entity(TypeRegistry.TEXT_DOCUMENT))&#13;&#10;        ));&#13;&#10;        assertFalse(resolver.isInstanceOf(javaEntity, TypeRegistry.FLAG, levelMap, ruleset));&#13;&#10;    }&#13;&#10;&#13;&#10;    @Test&#13;&#10;    void testSingleLevel_SelfTypeStillTrue() {&#13;&#10;        // Even with an EXTEND rule, direct type match still holds&#13;&#10;        ruleset.setRules(List.of(&#13;&#10;                extendRule(new Entity(TypeRegistry.TEXT_JAVA), new Entity(TypeRegistry.TEXT_DOCUMENT))&#13;&#10;        ));&#13;&#10;        assertTrue(resolver.isInstanceOf(javaEntity, TypeRegistry.JAVA, levelMap, ruleset));&#13;&#10;    }&#13;&#10;&#13;&#10;    // ── Multi-level chained inheritance ───────────────────────────────────────&#13;&#10;&#13;&#10;    @Test&#13;&#10;    void testMultiLevel_TransitiveMatch_ReturnsTrue() {&#13;&#10;        // ERROR EXTEND WARNING, WARNING EXTEND JAVA → ERROR instanceof JAVA (transitive)&#13;&#10;        ruleset.setRules(List.of(&#13;&#10;                extendRule(new Entity(TypeRegistry.TEXT_ERROR), new Entity(TypeRegistry.TEXT_WARNING)),&#13;&#10;                extendRule(new Entity(TypeRegistry.TEXT_WARNING), new Entity(TypeRegistry.TEXT_JAVA))&#13;&#10;        ));&#13;&#10;        assertTrue(resolver.isInstanceOf(errorEntity, TypeRegistry.JAVA, levelMap, ruleset));&#13;&#10;        assertTrue(resolver.isInstanceOf(errorEntity, TypeRegistry.WARNING, levelMap, ruleset));&#13;&#10;        assertTrue(resolver.isInstanceOf(errorEntity, TypeRegistry.ERROR, levelMap, ruleset));&#13;&#10;    }&#13;&#10;&#13;&#10;    @Test&#13;&#10;    void testMultiLevel_IntermediateType_NotMatchingOtherBranch() {&#13;&#10;        // ERROR EXTEND WARNING, WARNING EXTEND JAVA → ERROR instanceof DOCUMENT is false&#13;&#10;        ruleset.setRules(List.of(&#13;&#10;                extendRule(new Entity(TypeRegistry.TEXT_ERROR), new Entity(TypeRegistry.TEXT_WARNING)),&#13;&#10;                extendRule(new Entity(TypeRegistry.TEXT_WARNING), new Entity(TypeRegistry.TEXT_JAVA))&#13;&#10;        ));&#13;&#10;        assertFalse(resolver.isInstanceOf(errorEntity, TypeRegistry.DOCUMENT, levelMap, ruleset));&#13;&#10;    }&#13;&#10;&#13;&#10;    // ── Wrong direction ───────────────────────────────────────────────────────&#13;&#10;&#13;&#10;    @Test&#13;&#10;    void testWrongDirection_ReturnsFalse() {&#13;&#10;        // JAVA EXTEND DOCUMENT → DOCUMENT instanceof JAVA should be false&#13;&#10;        ruleset.setRules(List.of(&#13;&#10;                extendRule(new Entity(TypeRegistry.TEXT_JAVA), new Entity(TypeRegistry.TEXT_DOCUMENT))&#13;&#10;        ));&#13;&#10;        Entity documentEntity = new Entity(TypeRegistry.DOCUMENT);&#13;&#10;        levelMap.setPosition(documentEntity, 3, 3);&#13;&#10;        assertFalse(resolver.isInstanceOf(documentEntity, TypeRegistry.JAVA, levelMap, ruleset));&#13;&#10;    }&#13;&#10;&#13;&#10;    // ── Cycle guard ───────────────────────────────────────────────────────────&#13;&#10;&#13;&#10;    @Test&#13;&#10;    void testCycleGuard_DoesNotLoopInfinitely() {&#13;&#10;        // ERROR EXTEND WARNING, WARNING EXTEND ERROR (cycle)&#13;&#10;        ruleset.setRules(List.of(&#13;&#10;                extendRule(new Entity(TypeRegistry.TEXT_ERROR), new Entity(TypeRegistry.TEXT_WARNING)),&#13;&#10;                extendRule(new Entity(TypeRegistry.TEXT_WARNING), new Entity(TypeRegistry.TEXT_ERROR))&#13;&#10;        ));&#13;&#10;        // FLAG is outside the cycle → must return false without hanging&#13;&#10;        assertFalse(resolver.isInstanceOf(errorEntity, TypeRegistry.FLAG, levelMap, ruleset));&#13;&#10;        // Direct type match inside cycle still works&#13;&#10;        assertTrue(resolver.isInstanceOf(errorEntity, TypeRegistry.ERROR, levelMap, ruleset));&#13;&#10;    }&#13;&#10;&#13;&#10;    // ── IS rules must NOT create inheritance ──────────────────────────────────&#13;&#10;&#13;&#10;    @Test&#13;&#10;    void testIsRuleDoesNotCreateInheritance() {&#13;&#10;        // &quot;JAVA IS DOCUMENT&quot; rule — IS verb should be ignored by InheritanceResolver&#13;&#10;        Rule isRule = new Rule(&#13;&#10;                new Entity(TypeRegistry.TEXT_JAVA),&#13;&#10;                new Entity(TypeRegistry.IS),&#13;&#10;                new Entity(TypeRegistry.TEXT_DOCUMENT),&#13;&#10;                List.of()&#13;&#10;        );&#13;&#10;        ruleset.setRules(List.of(isRule));&#13;&#10;        assertFalse(resolver.isInstanceOf(javaEntity, TypeRegistry.DOCUMENT, levelMap, ruleset));&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>